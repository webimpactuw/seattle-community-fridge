{"ast":null,"code":"import { processOptions, validateOptions, getDefaultExportFromCjs } from \"./_chunks-es/_commonjsHelpers.js\";\nconst middlewareReducer = middleware => function (hook, defaultValue) {\n  const bailEarly = hook === \"onError\";\n  let value = defaultValue;\n  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    args[_key - 2] = arguments[_key];\n  }\n  for (let i = 0; i < middleware[hook].length; i++) {\n    const handler = middleware[hook][i];\n    if (value = handler(value, ...args), bailEarly && !value) break;\n  }\n  return value;\n};\nfunction createPubSub() {\n  const subscribers = /* @__PURE__ */Object.create(null);\n  let nextId = 0;\n  function subscribe(subscriber) {\n    const id = nextId++;\n    return subscribers[id] = subscriber, function () {\n      delete subscribers[id];\n    };\n  }\n  function publish(event) {\n    for (const id in subscribers) subscribers[id](event);\n  }\n  return {\n    publish,\n    subscribe\n  };\n}\nconst channelNames = [\"request\", \"response\", \"progress\", \"error\", \"abort\"],\n  middlehooks = [\"processOptions\", \"validateOptions\", \"interceptRequest\", \"finalizeOptions\", \"onRequest\", \"onResponse\", \"onError\", \"onReturn\", \"onHeaders\"];\nfunction createRequester(initMiddleware, httpRequest) {\n  const loadedMiddleware = [],\n    middleware = middlehooks.reduce((ware, name) => (ware[name] = ware[name] || [], ware), {\n      processOptions: [processOptions],\n      validateOptions: [validateOptions]\n    });\n  function request(opts) {\n    const onResponse = (reqErr, res, ctx) => {\n        let error = reqErr,\n          response = res;\n        if (!error) try {\n          response = applyMiddleware(\"onResponse\", res, ctx);\n        } catch (err) {\n          response = null, error = err;\n        }\n        error = error && applyMiddleware(\"onError\", error, ctx), error ? channels.error.publish(error) : response && channels.response.publish(response);\n      },\n      channels = channelNames.reduce((target, name) => (target[name] = createPubSub(), target), {}),\n      applyMiddleware = middlewareReducer(middleware),\n      options = applyMiddleware(\"processOptions\", opts);\n    applyMiddleware(\"validateOptions\", options);\n    const context = {\n      options,\n      channels,\n      applyMiddleware\n    };\n    let ongoingRequest;\n    const unsubscribe = channels.request.subscribe(ctx => {\n      ongoingRequest = httpRequest(ctx, (err, res) => onResponse(err, res, ctx));\n    });\n    channels.abort.subscribe(() => {\n      unsubscribe(), ongoingRequest && ongoingRequest.abort();\n    });\n    const returnValue = applyMiddleware(\"onReturn\", channels, context);\n    return returnValue === channels && channels.request.publish(context), returnValue;\n  }\n  return request.use = function (newMiddleware) {\n    if (!newMiddleware) throw new Error(\"Tried to add middleware that resolved to falsey value\");\n    if (typeof newMiddleware == \"function\") throw new Error(\"Tried to add middleware that was a function. It probably expects you to pass options to it.\");\n    if (newMiddleware.onReturn && middleware.onReturn.length > 0) throw new Error(\"Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event\");\n    return middlehooks.forEach(key => {\n      newMiddleware[key] && middleware[key].push(newMiddleware[key]);\n    }), loadedMiddleware.push(newMiddleware), request;\n  }, request.clone = () => createRequester(loadedMiddleware, httpRequest), initMiddleware.forEach(request.use), request;\n}\nvar trim = function (string) {\n    return string.replace(/^\\s+|\\s+$/g, \"\");\n  },\n  isArray = function (arg) {\n    return Object.prototype.toString.call(arg) === \"[object Array]\";\n  },\n  parseHeaders = function (headers) {\n    if (!headers) return {};\n    for (var result = {}, headersArr = trim(headers).split(\"\\n\"), i = 0; i < headersArr.length; i++) {\n      var row = headersArr[i],\n        index = row.indexOf(\":\"),\n        key = trim(row.slice(0, index)).toLowerCase(),\n        value = trim(row.slice(index + 1));\n      typeof result[key] > \"u\" ? result[key] = value : isArray(result[key]) ? result[key].push(value) : result[key] = [result[key], value];\n    }\n    return result;\n  },\n  parseHeaders$1 = /* @__PURE__ */getDefaultExportFromCjs(parseHeaders),\n  __defProp = Object.defineProperty,\n  __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value\n  }) : obj[key] = value,\n  __publicField = (obj, key, value) => (__defNormalProp(obj, typeof key != \"symbol\" ? key + \"\" : key, value), value),\n  __accessCheck = (obj, member, msg) => {\n    if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n  },\n  __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj)),\n  __privateAdd = (obj, member, value) => {\n    if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n  },\n  __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), member.set(obj, value), value),\n  _method,\n  _url,\n  _resHeaders,\n  _headers,\n  _controller,\n  _init,\n  _useAbortSignal;\nclass FetchXhr {\n  constructor() {\n    __publicField(this, \"onabort\"), __publicField(this, \"onerror\"), __publicField(this, \"onreadystatechange\"), __publicField(this, \"ontimeout\"), __publicField(this, \"readyState\", 0), __publicField(this, \"response\"), __publicField(this, \"responseText\", \"\"), __publicField(this, \"responseType\", \"\"), __publicField(this, \"status\"), __publicField(this, \"statusText\"), __publicField(this, \"withCredentials\"), __privateAdd(this, _method, void 0), __privateAdd(this, _url, void 0), __privateAdd(this, _resHeaders, void 0), __privateAdd(this, _headers, {}), __privateAdd(this, _controller, void 0), __privateAdd(this, _init, {}), __privateAdd(this, _useAbortSignal, void 0);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- _async is only declared for typings compatibility\n  open(method, url, _async) {\n    var _a;\n    __privateSet(this, _method, method), __privateSet(this, _url, url), __privateSet(this, _resHeaders, \"\"), this.readyState = 1, (_a = this.onreadystatechange) == null || _a.call(this), __privateSet(this, _controller, void 0);\n  }\n  abort() {\n    __privateGet(this, _controller) && __privateGet(this, _controller).abort();\n  }\n  getAllResponseHeaders() {\n    return __privateGet(this, _resHeaders);\n  }\n  setRequestHeader(name, value) {\n    __privateGet(this, _headers)[name] = value;\n  }\n  // Allow setting extra fetch init options, needed for runtimes such as Vercel Edge to set `cache` and other options in React Server Components\n  setInit(init) {\n    let useAbortSignal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n    __privateSet(this, _init, init), __privateSet(this, _useAbortSignal, useAbortSignal);\n  }\n  send(body) {\n    const textBody = this.responseType !== \"arraybuffer\",\n      options = {\n        ...__privateGet(this, _init),\n        method: __privateGet(this, _method),\n        headers: __privateGet(this, _headers),\n        body\n      };\n    typeof AbortController == \"function\" && __privateGet(this, _useAbortSignal) && (__privateSet(this, _controller, new AbortController()), typeof EventTarget < \"u\" && __privateGet(this, _controller).signal instanceof EventTarget && (options.signal = __privateGet(this, _controller).signal)), typeof document < \"u\" && (options.credentials = this.withCredentials ? \"include\" : \"omit\"), fetch(__privateGet(this, _url), options).then(res => (res.headers.forEach((value, key) => {\n      __privateSet(this, _resHeaders, __privateGet(this, _resHeaders) + \"\".concat(key, \": \").concat(value, \"\\r\\n\"));\n    }), this.status = res.status, this.statusText = res.statusText, this.readyState = 3, textBody ? res.text() : res.arrayBuffer())).then(resBody => {\n      var _a;\n      typeof resBody == \"string\" ? this.responseText = resBody : this.response = resBody, this.readyState = 4, (_a = this.onreadystatechange) == null || _a.call(this);\n    }).catch(err => {\n      var _a, _b;\n      if (err.name === \"AbortError\") {\n        (_a = this.onabort) == null || _a.call(this);\n        return;\n      }\n      (_b = this.onerror) == null || _b.call(this, err);\n    });\n  }\n}\n_method = /* @__PURE__ */new WeakMap(), _url = /* @__PURE__ */new WeakMap(), _resHeaders = /* @__PURE__ */new WeakMap(), _headers = /* @__PURE__ */new WeakMap(), _controller = /* @__PURE__ */new WeakMap(), _init = /* @__PURE__ */new WeakMap(), _useAbortSignal = /* @__PURE__ */new WeakMap();\nconst adapter = typeof XMLHttpRequest == \"function\" ? \"xhr\" : \"fetch\",\n  XmlHttpRequest = adapter === \"xhr\" ? XMLHttpRequest : FetchXhr,\n  httpRequester = (context, callback) => {\n    var _a;\n    const opts = context.options,\n      options = context.applyMiddleware(\"finalizeOptions\", opts),\n      timers = {},\n      injectedResponse = context.applyMiddleware(\"interceptRequest\", void 0, {\n        adapter,\n        context\n      });\n    if (injectedResponse) {\n      const cbTimer = setTimeout(callback, 0, null, injectedResponse);\n      return {\n        abort: () => clearTimeout(cbTimer)\n      };\n    }\n    let xhr = new XmlHttpRequest();\n    xhr instanceof FetchXhr && typeof options.fetch == \"object\" && xhr.setInit(options.fetch, (_a = options.useAbortSignal) != null ? _a : !0);\n    const headers = options.headers,\n      delays = options.timeout;\n    let aborted = !1,\n      loaded = !1,\n      timedOut = !1;\n    if (xhr.onerror = event => {\n      xhr instanceof FetchXhr ? onError(event instanceof Error ? event : new Error(\"Request error while attempting to reach is \".concat(options.url), {\n        cause: event\n      })) : onError(new Error(\"Request error while attempting to reach is \".concat(options.url).concat(event.lengthComputable ? \"(\".concat(event.loaded, \" of \").concat(event.total, \" bytes transferred)\") : \"\")));\n    }, xhr.ontimeout = event => {\n      onError(new Error(\"Request timeout while attempting to reach \".concat(options.url).concat(event.lengthComputable ? \"(\".concat(event.loaded, \" of \").concat(event.total, \" bytes transferred)\") : \"\")));\n    }, xhr.onabort = () => {\n      stopTimers(!0), aborted = !0;\n    }, xhr.onreadystatechange = () => {\n      resetTimers(), !(aborted || xhr.readyState !== 4) && xhr.status !== 0 && onLoad();\n    }, xhr.open(options.method, options.url, !0\n    // Always async\n    ), xhr.withCredentials = !!options.withCredentials, headers && xhr.setRequestHeader) for (const key in headers) headers.hasOwnProperty(key) && xhr.setRequestHeader(key, headers[key]);\n    return options.rawBody && (xhr.responseType = \"arraybuffer\"), context.applyMiddleware(\"onRequest\", {\n      options,\n      adapter,\n      request: xhr,\n      context\n    }), xhr.send(options.body || null), delays && (timers.connect = setTimeout(() => timeoutRequest(\"ETIMEDOUT\"), delays.connect)), {\n      abort\n    };\n    function abort() {\n      aborted = !0, xhr && xhr.abort();\n    }\n    function timeoutRequest(code) {\n      timedOut = !0, xhr.abort();\n      const error = new Error(code === \"ESOCKETTIMEDOUT\" ? \"Socket timed out on request to \".concat(options.url) : \"Connection timed out on request to \".concat(options.url));\n      error.code = code, context.channels.error.publish(error);\n    }\n    function resetTimers() {\n      delays && (stopTimers(), timers.socket = setTimeout(() => timeoutRequest(\"ESOCKETTIMEDOUT\"), delays.socket));\n    }\n    function stopTimers(force) {\n      (force || aborted || xhr.readyState >= 2 && timers.connect) && clearTimeout(timers.connect), timers.socket && clearTimeout(timers.socket);\n    }\n    function onError(error) {\n      if (loaded) return;\n      stopTimers(!0), loaded = !0, xhr = null;\n      const err = error || new Error(\"Network error while attempting to reach \".concat(options.url));\n      err.isNetworkError = !0, err.request = options, callback(err);\n    }\n    function reduceResponse() {\n      return {\n        body: xhr.response || (xhr.responseType === \"\" || xhr.responseType === \"text\" ? xhr.responseText : \"\"),\n        url: options.url,\n        method: options.method,\n        headers: parseHeaders$1(xhr.getAllResponseHeaders()),\n        statusCode: xhr.status,\n        statusMessage: xhr.statusText\n      };\n    }\n    function onLoad() {\n      if (!(aborted || loaded || timedOut)) {\n        if (xhr.status === 0) {\n          onError(new Error(\"Unknown XHR error\"));\n          return;\n        }\n        stopTimers(), loaded = !0, callback(null, reduceResponse());\n      }\n    }\n  },\n  getIt = function () {\n    let initMiddleware = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let httpRequest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : httpRequester;\n    return createRequester(initMiddleware, httpRequest);\n  },\n  environment = \"browser\";\nexport { adapter, environment, getIt };","map":{"version":3,"names":["middlewareReducer","middleware","hook","defaultValue","bailEarly","value","_len","arguments","length","args","Array","_key","i","handler","createPubSub","subscribers","Object","create","nextId","subscribe","subscriber","id","publish","event","channelNames","middlehooks","createRequester","initMiddleware","httpRequest","loadedMiddleware","reduce","ware","name","processOptions","validateOptions","request","opts","onResponse","reqErr","res","ctx","error","response","applyMiddleware","err","channels","target","options","context","ongoingRequest","unsubscribe","abort","returnValue","use","newMiddleware","Error","onReturn","forEach","key","push","clone","trim","string","replace","isArray","arg","prototype","toString","call","parseHeaders","headers","result","headersArr","split","row","index","indexOf","slice","toLowerCase","parseHeaders$1","getDefaultExportFromCjs","__defProp","defineProperty","__defNormalProp","obj","enumerable","configurable","writable","__publicField","__accessCheck","member","msg","_method","_url","_resHeaders","_headers","_controller","_init","_useAbortSignal","FetchXhr","constructor","__privateAdd","open","method","url","_async","_a","__privateSet","readyState","onreadystatechange","__privateGet","getAllResponseHeaders","setRequestHeader","setInit","init","useAbortSignal","undefined","send","body","textBody","responseType","AbortController","EventTarget","signal","document","credentials","withCredentials","fetch","then","concat","status","statusText","text","arrayBuffer","resBody","responseText","catch","_b","onabort","onerror","WeakMap","adapter","XMLHttpRequest","XmlHttpRequest","httpRequester","callback","timers","injectedResponse","cbTimer","setTimeout","clearTimeout","xhr","delays","timeout","aborted","loaded","timedOut","onError","cause","lengthComputable","total","ontimeout","stopTimers","resetTimers","onLoad","hasOwnProperty","rawBody","connect","timeoutRequest","code","socket","force","isNetworkError","reduceResponse","statusCode","statusMessage","getIt","environment"],"sources":["C:\\Projects\\seattle-community-fridge\\node_modules\\get-it\\src\\util\\middlewareReducer.ts","C:\\Projects\\seattle-community-fridge\\node_modules\\get-it\\src\\util\\pubsub.ts","C:\\Projects\\seattle-community-fridge\\node_modules\\get-it\\src\\createRequester.ts","C:\\Projects\\seattle-community-fridge\\node_modules\\get-it\\node_modules\\parse-headers\\parse-headers.js","C:\\Projects\\seattle-community-fridge\\node_modules\\get-it\\src\\request\\browser\\fetchXhr.ts","C:\\Projects\\seattle-community-fridge\\node_modules\\get-it\\src\\request\\browser-request.ts","C:\\Projects\\seattle-community-fridge\\node_modules\\get-it\\src\\index.browser.ts"],"sourcesContent":["import type {ApplyMiddleware, MiddlewareReducer} from 'get-it'\n\nexport const middlewareReducer = (middleware: MiddlewareReducer) =>\n  function applyMiddleware(hook, defaultValue, ...args) {\n    const bailEarly = hook === 'onError'\n\n    let value = defaultValue\n    for (let i = 0; i < middleware[hook].length; i++) {\n      const handler = middleware[hook][i]\n      // @ts-expect-error -- find a better way to deal with argument tuples\n      value = handler(value, ...args)\n\n      if (bailEarly && !value) {\n        break\n      }\n    }\n\n    return value\n  } as ApplyMiddleware\n","// Code borrowed from https://github.com/bjoerge/nano-pubsub\n\nimport type {PubSub, Subscriber} from 'get-it'\n\nexport function createPubSub<Message = void>(): PubSub<Message> {\n  const subscribers: {[id: string]: Subscriber<Message>} = Object.create(null)\n  let nextId = 0\n  function subscribe(subscriber: Subscriber<Message>) {\n    const id = nextId++\n    subscribers[id] = subscriber\n    return function unsubscribe() {\n      delete subscribers[id]\n    }\n  }\n\n  function publish(event: Message) {\n    for (const id in subscribers) {\n      subscribers[id](event)\n    }\n  }\n\n  return {\n    publish,\n    subscribe,\n  }\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {processOptions} from './middleware/defaultOptionsProcessor'\nimport {validateOptions} from './middleware/defaultOptionsValidator'\nimport type {\n  HttpContext,\n  HttpRequest,\n  HttpRequestOngoing,\n  Middleware,\n  MiddlewareChannels,\n  MiddlewareHooks,\n  MiddlewareReducer,\n  MiddlewareResponse,\n  Middlewares,\n  Requester,\n  RequestOptions,\n} from './types'\nimport {middlewareReducer} from './util/middlewareReducer'\nimport {createPubSub} from './util/pubsub'\n\nconst channelNames = [\n  'request',\n  'response',\n  'progress',\n  'error',\n  'abort',\n] satisfies (keyof MiddlewareChannels)[]\nconst middlehooks = [\n  'processOptions',\n  'validateOptions',\n  'interceptRequest',\n  'finalizeOptions',\n  'onRequest',\n  'onResponse',\n  'onError',\n  'onReturn',\n  'onHeaders',\n] satisfies (keyof MiddlewareHooks)[]\n\n/** @public */\nexport function createRequester(initMiddleware: Middlewares, httpRequest: HttpRequest): Requester {\n  const loadedMiddleware: Middlewares = []\n  const middleware: MiddlewareReducer = middlehooks.reduce(\n    (ware, name) => {\n      ware[name] = ware[name] || []\n      return ware\n    },\n    {\n      processOptions: [processOptions],\n      validateOptions: [validateOptions],\n    } as any,\n  )\n\n  function request(opts: RequestOptions | string) {\n    const onResponse = (reqErr: Error | null, res: MiddlewareResponse, ctx: HttpContext) => {\n      let error = reqErr\n      let response: MiddlewareResponse | null = res\n\n      // We're processing non-errors first, in case a middleware converts the\n      // response into an error (for instance, status >= 400 == HttpError)\n      if (!error) {\n        try {\n          response = applyMiddleware('onResponse', res, ctx)\n        } catch (err: any) {\n          response = null\n          error = err\n        }\n      }\n\n      // Apply error middleware - if middleware return the same (or a different) error,\n      // publish as an error event. If we *don't* return an error, assume it has been handled\n      error = error && applyMiddleware('onError', error, ctx)\n\n      // Figure out if we should publish on error/response channels\n      if (error) {\n        channels.error.publish(error)\n      } else if (response) {\n        channels.response.publish(response)\n      }\n    }\n\n    const channels: MiddlewareChannels = channelNames.reduce((target, name) => {\n      target[name] = createPubSub() as MiddlewareChannels[typeof name]\n      return target\n    }, {} as any)\n\n    // Prepare a middleware reducer that can be reused throughout the lifecycle\n    const applyMiddleware = middlewareReducer(middleware)\n\n    // Parse the passed options\n    const options = applyMiddleware('processOptions', opts as RequestOptions)\n\n    // Validate the options\n    applyMiddleware('validateOptions', options)\n\n    // Build a context object we can pass to child handlers\n    const context = {options, channels, applyMiddleware}\n\n    // We need to hold a reference to the current, ongoing request,\n    // in order to allow cancellation. In the case of the retry middleware,\n    // a new request might be triggered\n    let ongoingRequest: HttpRequestOngoing | undefined\n    const unsubscribe = channels.request.subscribe((ctx) => {\n      // Let request adapters (node/browser) perform the actual request\n      ongoingRequest = httpRequest(ctx, (err, res) => onResponse(err, res!, ctx))\n    })\n\n    // If we abort the request, prevent further requests from happening,\n    // and be sure to cancel any ongoing request (obviously)\n    channels.abort.subscribe(() => {\n      unsubscribe()\n      if (ongoingRequest) {\n        ongoingRequest.abort()\n      }\n    })\n\n    // See if any middleware wants to modify the return value - for instance\n    // the promise or observable middlewares\n    const returnValue = applyMiddleware('onReturn', channels, context)\n\n    // If return value has been modified by a middleware, we expect the middleware\n    // to publish on the 'request' channel. If it hasn't been modified, we want to\n    // trigger it right away\n    if (returnValue === channels) {\n      channels.request.publish(context)\n    }\n\n    return returnValue\n  }\n\n  request.use = function use(newMiddleware: Middleware) {\n    if (!newMiddleware) {\n      throw new Error('Tried to add middleware that resolved to falsey value')\n    }\n\n    if (typeof newMiddleware === 'function') {\n      throw new Error(\n        'Tried to add middleware that was a function. It probably expects you to pass options to it.',\n      )\n    }\n\n    if (newMiddleware.onReturn && middleware.onReturn.length > 0) {\n      throw new Error(\n        'Tried to add new middleware with `onReturn` handler, but another handler has already been registered for this event',\n      )\n    }\n\n    middlehooks.forEach((key) => {\n      if (newMiddleware[key]) {\n        middleware[key].push(newMiddleware[key] as any)\n      }\n    })\n\n    loadedMiddleware.push(newMiddleware)\n    return request\n  }\n\n  request.clone = () => createRequester(loadedMiddleware, httpRequest)\n\n  initMiddleware.forEach(request.use)\n\n  return request\n}\n","var trim = function(string) {\n  return string.replace(/^\\s+|\\s+$/g, '');\n}\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  var headersArr = trim(headers).split('\\n')\n\n  for (var i = 0; i < headersArr.length; i++) {\n    var row = headersArr[i]\n    var index = row.indexOf(':')\n    , key = trim(row.slice(0, index)).toLowerCase()\n    , value = trim(row.slice(index + 1))\n\n    if (typeof(result[key]) === 'undefined') {\n      result[key] = value\n    } else if (isArray(result[key])) {\n      result[key].push(value)\n    } else {\n      result[key] = [ result[key], value ]\n    }\n  }\n\n  return result\n}\n","/**\n * Mimicks the XMLHttpRequest API with only the parts needed for get-it's XHR adapter\n */\nexport class FetchXhr\n  implements Pick<XMLHttpRequest, 'open' | 'abort' | 'getAllResponseHeaders' | 'setRequestHeader'>\n{\n  /**\n   * Public interface, interop with real XMLHttpRequest\n   */\n  onabort: (() => void) | undefined\n  onerror: ((error?: any) => void) | undefined\n  onreadystatechange: (() => void) | undefined\n  ontimeout: XMLHttpRequest['ontimeout'] | undefined\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/readyState\n   */\n  readyState: 0 | 1 | 2 | 3 | 4 = 0\n  response: XMLHttpRequest['response']\n  responseText: XMLHttpRequest['responseText'] = ''\n  responseType: XMLHttpRequest['responseType'] = ''\n  status: XMLHttpRequest['status'] | undefined\n  statusText: XMLHttpRequest['statusText'] | undefined\n  withCredentials: XMLHttpRequest['withCredentials'] | undefined\n\n  /**\n   * Private implementation details\n   */\n  #method!: string\n  #url!: string\n  #resHeaders!: string\n  #headers: Record<string, string> = {}\n  #controller?: AbortController\n  #init: RequestInit = {}\n  #useAbortSignal?: boolean\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars -- _async is only declared for typings compatibility\n  open(method: string, url: string, _async?: boolean) {\n    this.#method = method\n    this.#url = url\n    this.#resHeaders = ''\n    this.readyState = 1 // Open\n    this.onreadystatechange?.()\n    this.#controller = undefined\n  }\n  abort() {\n    if (this.#controller) {\n      this.#controller.abort()\n    }\n  }\n  getAllResponseHeaders() {\n    return this.#resHeaders\n  }\n  setRequestHeader(name: string, value: string) {\n    this.#headers[name] = value\n  }\n  // Allow setting extra fetch init options, needed for runtimes such as Vercel Edge to set `cache` and other options in React Server Components\n  setInit(init: RequestInit, useAbortSignal = true) {\n    this.#init = init\n    this.#useAbortSignal = useAbortSignal\n  }\n  send(body: BodyInit) {\n    const textBody = this.responseType !== 'arraybuffer'\n    const options: RequestInit = {\n      ...this.#init,\n      method: this.#method,\n      headers: this.#headers,\n      body,\n    }\n    if (typeof AbortController === 'function' && this.#useAbortSignal) {\n      this.#controller = new AbortController()\n      // The instanceof check ensures environments like Edge Runtime, Node 18 with built-in fetch\n      // and more don't throw if `signal` doesn't implement`EventTarget`\n      // Native browser AbortSignal implements EventTarget, so we can use it\n      if (typeof EventTarget !== 'undefined' && this.#controller.signal instanceof EventTarget) {\n        options.signal = this.#controller.signal\n      }\n    }\n\n    // Some environments (like CloudFlare workers) don't support credentials in\n    // RequestInitDict, and there doesn't seem to be any easy way to check for it,\n    // so for now let's just make do with a document check :/\n    if (typeof document !== 'undefined') {\n      options.credentials = this.withCredentials ? 'include' : 'omit'\n    }\n\n    fetch(this.#url, options)\n      .then((res): Promise<string | ArrayBuffer> => {\n        res.headers.forEach((value: any, key: any) => {\n          this.#resHeaders += `${key}: ${value}\\r\\n`\n        })\n        this.status = res.status\n        this.statusText = res.statusText\n        this.readyState = 3 // Loading\n        return textBody ? res.text() : res.arrayBuffer()\n      })\n      .then((resBody) => {\n        if (typeof resBody === 'string') {\n          this.responseText = resBody\n        } else {\n          this.response = resBody\n        }\n        this.readyState = 4 // Done\n        this.onreadystatechange?.()\n      })\n      .catch((err: Error) => {\n        if (err.name === 'AbortError') {\n          this.onabort?.()\n          return\n        }\n\n        this.onerror?.(err)\n      })\n  }\n}\n","import type {HttpRequest, MiddlewareResponse, RequestOptions} from 'get-it'\nimport parseHeaders from 'parse-headers'\n\nimport {FetchXhr} from './browser/fetchXhr'\n\n/**\n * Use fetch if it's available, non-browser environments such as Deno, Edge Runtime and more provide fetch as a global but doesn't provide xhr\n * @public\n */\nexport const adapter = (\n  typeof XMLHttpRequest === 'function' ? ('xhr' as const) : ('fetch' as const)\n) satisfies import('../types').RequestAdapter\n\n// Fallback to fetch-based XHR polyfill for non-browser environments like Workers\nconst XmlHttpRequest = adapter === 'xhr' ? XMLHttpRequest : FetchXhr\n\nexport const httpRequester: HttpRequest = (context, callback) => {\n  const opts = context.options\n  const options = context.applyMiddleware('finalizeOptions', opts) as RequestOptions\n  const timers: any = {}\n\n  // Allow middleware to inject a response, for instance in the case of caching or mocking\n  const injectedResponse = context.applyMiddleware('interceptRequest', undefined, {\n    adapter,\n    context,\n  })\n\n  // If middleware injected a response, treat it as we normally would and return it\n  // Do note that the injected response has to be reduced to a cross-environment friendly response\n  if (injectedResponse) {\n    const cbTimer = setTimeout(callback, 0, null, injectedResponse)\n    const cancel = () => clearTimeout(cbTimer)\n    return {abort: cancel}\n  }\n\n  // We'll want to null out the request on success/failure\n  let xhr = new XmlHttpRequest()\n\n  if (xhr instanceof FetchXhr && typeof options.fetch === 'object') {\n    xhr.setInit(options.fetch, options.useAbortSignal ?? true)\n  }\n\n  const headers = options.headers\n  const delays = options.timeout\n\n  // Request state\n  let aborted = false\n  let loaded = false\n  let timedOut = false\n\n  // Apply event handlers\n  xhr.onerror = (event: ProgressEvent) => {\n    // If fetch is used then rethrow the original error\n    if (xhr instanceof FetchXhr) {\n      onError(\n        event instanceof Error\n          ? event\n          : new Error(`Request error while attempting to reach is ${options.url}`, {cause: event}),\n      )\n    } else {\n      onError(\n        new Error(\n          `Request error while attempting to reach is ${options.url}${\n            event.lengthComputable ? `(${event.loaded} of ${event.total} bytes transferred)` : ''\n          }`,\n        ),\n      )\n    }\n  }\n  xhr.ontimeout = (event: ProgressEvent) => {\n    onError(\n      new Error(\n        `Request timeout while attempting to reach ${options.url}${\n          event.lengthComputable ? `(${event.loaded} of ${event.total} bytes transferred)` : ''\n        }`,\n      ),\n    )\n  }\n  xhr.onabort = () => {\n    stopTimers(true)\n    aborted = true\n  }\n\n  xhr.onreadystatechange = () => {\n    // Prevent request from timing out\n    resetTimers()\n\n    if (aborted || xhr.readyState !== 4) {\n      return\n    }\n\n    // Will be handled by onError\n    if (xhr.status === 0) {\n      return\n    }\n\n    onLoad()\n  }\n\n  // @todo two last options to open() is username/password\n  xhr.open(\n    options.method!,\n    options.url,\n    true, // Always async\n  )\n\n  // Some options need to be applied after open\n  xhr.withCredentials = !!options.withCredentials\n\n  // Set headers\n  if (headers && xhr.setRequestHeader) {\n    for (const key in headers) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (headers.hasOwnProperty(key)) {\n        xhr.setRequestHeader(key, headers[key])\n      }\n    }\n  }\n\n  if (options.rawBody) {\n    xhr.responseType = 'arraybuffer'\n  }\n\n  // Let middleware know we're about to do a request\n  context.applyMiddleware('onRequest', {options, adapter, request: xhr, context})\n\n  xhr.send(options.body || null)\n\n  // Figure out which timeouts to use (if any)\n  if (delays) {\n    timers.connect = setTimeout(() => timeoutRequest('ETIMEDOUT'), delays.connect)\n  }\n\n  return {abort}\n\n  function abort() {\n    aborted = true\n\n    if (xhr) {\n      xhr.abort()\n    }\n  }\n\n  function timeoutRequest(code: any) {\n    timedOut = true\n    xhr.abort()\n    const error: any = new Error(\n      code === 'ESOCKETTIMEDOUT'\n        ? `Socket timed out on request to ${options.url}`\n        : `Connection timed out on request to ${options.url}`,\n    )\n    error.code = code\n    context.channels.error.publish(error)\n  }\n\n  function resetTimers() {\n    if (!delays) {\n      return\n    }\n\n    stopTimers()\n    timers.socket = setTimeout(() => timeoutRequest('ESOCKETTIMEDOUT'), delays.socket)\n  }\n\n  function stopTimers(force?: boolean) {\n    // Only clear the connect timeout if we've got a connection\n    if (force || aborted || (xhr.readyState >= 2 && timers.connect)) {\n      clearTimeout(timers.connect)\n    }\n\n    if (timers.socket) {\n      clearTimeout(timers.socket)\n    }\n  }\n\n  function onError(error: Error) {\n    if (loaded) {\n      return\n    }\n\n    // Clean up\n    stopTimers(true)\n    loaded = true\n    ;(xhr as any) = null\n\n    // Annoyingly, details are extremely scarce and hidden from us.\n    // We only really know that it is a network error\n    const err = (error ||\n      new Error(`Network error while attempting to reach ${options.url}`)) as Error & {\n      isNetworkError: boolean\n      request?: typeof options\n    }\n    err.isNetworkError = true\n    err.request = options\n    callback(err)\n  }\n\n  function reduceResponse(): MiddlewareResponse {\n    return {\n      body:\n        xhr.response ||\n        (xhr.responseType === '' || xhr.responseType === 'text' ? xhr.responseText : ''),\n      url: options.url,\n      method: options.method!,\n      headers: parseHeaders(xhr.getAllResponseHeaders()),\n      statusCode: xhr.status!,\n      statusMessage: xhr.statusText!,\n    }\n  }\n\n  function onLoad() {\n    if (aborted || loaded || timedOut) {\n      return\n    }\n\n    if (xhr.status === 0) {\n      onError(new Error('Unknown XHR error'))\n      return\n    }\n\n    // Prevent being called twice\n    stopTimers()\n    loaded = true\n    callback(null, reduceResponse())\n  }\n}\n","import {createRequester} from './createRequester'\nimport {httpRequester} from './request/browser-request'\nimport type {ExportEnv, HttpRequest, Middlewares, Requester} from './types'\n\nexport type * from './types'\n\n/** @public */\nexport const getIt = (\n  initMiddleware: Middlewares = [],\n  httpRequest: HttpRequest = httpRequester,\n): Requester => createRequester(initMiddleware, httpRequest)\n\n/** @public */\nexport const environment = 'browser' satisfies ExportEnv\n\n/** @public */\nexport {adapter} from './request/browser-request'\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}